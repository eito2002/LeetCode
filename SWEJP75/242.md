# [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

## step 1

最初の解法、Two Sumを思い出して`unordered_map`を使うことに、ループとしては各文字列1回づつ、計算量はO(N)
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        unordered_map<char, int> dict;
        for (char c : s) {
            ++dict[c];
        }
        for (char c : t) {
            if (dict.count(c)) {
                --dict[c];
            }
            if (dict[c] == 0) {
                dict.erase(c);
            }
        }
        return dict.size() == 0;
    }
};
```

しかし遅いので、単純にソートも試してみる、そんなに変わらないらしい。
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```

diffを取ればループ一回出行けるのでは？（これは弾かれた、{"ggii", "eekk"}のような場合に対応できない）
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        int diff = 0;
        for (int i = 0; i < s.size(); ++i) {
            diff += s[i] - t[i];
        }
        return diff == 0;
    }
};
```

## step2
他の人のコードを見る
- https://github.com/colorbox/leetcode/pull/9
- https://github.com/NobukiFukui/Grind75-ProgrammingTraining/pull/21
- https://github.com/kzhra/Grind41/pull/8

解法はおおよそ同じ。

> lookupの計算量がmapだとO(logn)でunorderd_mapだとO(1)ですが、ハッシュ化の定数倍の処理などがあるからnがすごく大きくない限りはそこまで変わらないみたいな感じですね。挿入についても同様。

- https://github.com/huyfififi/coding-challenges/blob/079ec6930588f34749607db1bf268973f8582444/leetcode/242/memo.md

がUnicode文字処理の参考に。

## Step3
kzhraさんのを参考にして、ループ一回でできるようになった。

- `const auto&`で省メモリ(今回の場合はあまり変わらないかもしれないが)
- 途中で早期リターン
- 後ろにつけると変更前にコピーが生じるため、++, --は前につける

が工夫点。
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        unordered_map<char, int> dict;
        for (int i = 0; i < s.size(); ++i) {
            ++dict[s[i]];
            --dict[t[i]];
        }
        for (const auto& [key, val] : dict) {
            if (val != 0) {
                return false;
            }
        }
        return true;
    }
};
```

by ChatGPT 4.1
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) return false;
        vector<int> count(26, 0);
        for (int i = 0; i < s.length(); ++i) {
            count[s[i] - 'a']++;
            count[t[i] - 'a']--;
        }
        for (int n : count) {
            if (n != 0) return false;
        }
        return true;
    }
};
```
小文字アルファベットのvectorのみで省メモリ
